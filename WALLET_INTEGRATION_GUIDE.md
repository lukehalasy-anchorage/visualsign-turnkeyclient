# Wallet Integrators Guide to VisualSign Protocol (VSP)

## Executive Summary

The VisualSign Protocol (VSP) provides cryptographically verifiable transaction parsing through AWS Nitro Enclaves. This guide demonstrates how wallets can incrementally integrate VSP verification, starting with basic signature validation and progressively adding stronger security guarantees.

This repository [visualsign-turnkeyclient](https://github.com/anchorageoss/visualsign-turnkeyclient) demonstrates building a minimal portable verifier for [visualsign-parser](https://github.com/anchorageoss/visualsign-parser) with minimal dependencies:

* Go stdlib (built-in cryptography)
* [awsnitroverifier](https://github.com/anchorageoss/awsnitroverifier) (includes [cbor](https://github.com/fxamacker/cbor/))

## VisualSign Protocol from a Wallet's perspective

VisualSign is blockchain protocol agnostic and enables incremental wallet integration. We validate an opaque set of bytes, which provides integrity while allowing future UI standardization flexibility.

VSP protects against:
- Supply chain attacks on transaction parsing code (of course crates.io could get compromised)
- Man-in-the-middle attacks on transaction data
- Compromised, altered data provided to wallet frontend by a dapp

### Incremental Integration Path

Wallets can adopt VSP verification in three progressive levels (doesn't include the time to write good tests and code reviews):

1. **Level 1**: Basic P256 signature verification (< day implementation for most wallets)
2. **Level 2**: Boot attestation with PCR validation (3-5 days implementation)
3. **Level 3**: Complete manifest verification (5-10 days implementation)

Each level provides meaningful security improvements while allowing teams to balance implementation complexity against security requirements.

## Architecture Overview

### System Components


```
[Wallet] → [Turnkey API] → [AWS Nitro Enclave]
                                └─ QuorumOS (QoS)
                                    ├─ visualsign-parser
                                    └─ Ephemeral P256 Key
           ← [Parsed Transaction with Attestations]
```

### Key Components

- **AWS Nitro Enclave**: Hardware-isolated compute environment that prevents even privileged users from accessing running code
- **QuorumOS (QoS)**: Turnkey's secure operating system implementing threshold cryptography [GitHub Repo](https://github.com/tkhq/qos)
- **visualsign-parser**: The application binary running inside the enclave 
[GitHub Repo](https://github.com/anchorageoss/visualsign-parser)
- **Attestations**: Cryptographic proofs of the enclave's configuration and operation. The primary one is Boot Attestation, which includes Userdata and Public Key, which can be used for validating the binary, as well as the App Attestation, which allows verification of the response content integrity.


## Level 1: Basic P256 Signature Verification

### Overview

Level 1 verifies the ECDSA P256 signature from an ephemeral key generated inside the enclave, confirming the transaction was parsed by a program in Turnkey's infrastructure.

### What You Get

- ✅ Verification that transaction was parsed by some program running in Turnkey's Infrastructure; but no guarantee that it was generated by [VisualSign Parser](https://github.com/anchorageoss/visualsign-parser)
- ✅ Protection against signature forgery
- ✅ Basic integrity check on transaction data
- ✅ Minimal implementation complexity

### What You Don't Get

- ❌ No proof that parsing happened in secure enclave
- ❌ No verification of enclave configuration

### Implementation

#### Step 1: Call the API

#### Step 2: Extract App Attestation

#### Step 3: Extract Public Key

The public key is a 130-byte hex string. Use the latter 65 bytes for verification:

#### Step 4: Verify the Signature

#### Step 5: Return the Signable Payload (this is the payload we show to the user)

### Testing Level 1

See: https://github.com/anchorageoss/visualsign-turnkeyclient/blob/5f35d58113d81cd256cbb0ab4a130f1b8903d1e4/verify/service.go#L132-L158

---

## Level 2: Boot Attestation with PCR Validation

### Overview

Level 2 adds cryptographic proof that parsing occurred inside an AWS Nitro Enclave by verifying the boot attestation document and Platform Configuration Register (PCR) values.

### What You Get

- ✅ All Level 1 guarantees
- ✅ Cryptographic proof of enclave execution
- ✅ Verification of software stack via PCR values
- ✅ Protection against API compromise
- ✅ AWS-signed attestation that cannot be forged


### What You Don't Get

- ❌ PCR values only attest up to QoS (kernel/OS), not the application binary


See [Understanding PCR Measurements](#understanding-pcr-measurements) for more details.

For Turnkey enclaves, PCR2 == PCR1 because Turnkey does not use pivot_root, and simply uses initramfs as the final filesystem.

### Reference Implementation

#### Step 1: Install AWS Nitro Verifier

```bash
go get github.com/anchorageoss/awsnitroverifier@latest
```

#### Step 2: Extract and Verify Boot Attestation

Use [awsnitroverifier](https://github.com/anchorageoss/awsnitroverifier) to verify the attestation. [Example code](https://github.com/anchorageoss/visualsign-turnkeyclient/blob/0cca7651b8fcd3cf569602e4db7919acf3f022c8/verify/service.go#L90-L102)

#### Step 3: Validate PCR Values

Verify PCRs from the AttestationDocument against your QuorumOS build. [Example code](https://github.com/anchorageoss/visualsign-turnkeyclient/blob/0cca7651b8fcd3cf569602e4db7919acf3f022c8/verify/service.go#L112-L122)

#### Step 4: Maintain PCR Allowlist

You can maintain a list of PCRs that are valid and run this for validation:
```go
./bin/visualsign-turnkeyclient verify --host https://api.turnkey.com \ 
                                      --organization-id <your organization> \
                                      --key-name <your key> \
                                      --unsigned-payload "<payload>"\
                                      --chain CHAIN_<NAME> \
                                      --pcrs 0:<PCR0Hex>,1:<PCR1Hex> --qos-manifest-hex 265e6e93364c1d45d3a0bd15899cc8ce035f4c4262f1192b2211ac7b7f9531e6
```


## Level 3: Complete Manifest Verification

### Overview

Level 3 verifies the exact visualsign-parser binary running in the enclave through the QuorumOS (QoS) manifest.

### What You Get

- ✅ All Level 1 & 2 guarantees
- ✅ Verification of exact application binary (SHA256)
- ✅ Protection against unauthorized manifest updates
- ✅ Complete verification of code on genuine AWS Nitro instance

### Understanding the QoS Manifest

The manifest is a [Borsh-encoded struct](https://github.com/tkhq/qos/blob/b86ad1b22f74263b22da65d88c18096e07841ad8/src/qos_core/src/protocol/services/boot.rs#L297-L330) containing the SHA256 hash of visualsign-parser in the **`Pivot.Hash`** field.

### Implementation

#### Step 1: Decode Manifest

Use a Borsh library to decode the manifest. [Reference implementation](https://github.com/anchorageoss/visualsign-turnkeyclient/tree/main/manifest)

#### Step 2: Verify Manifest Hash

Verify the UserData field in the boot attestation matches the SHA256 hash of the manifest.

#### Step 3: Validate Binary Hash

Verify `Pivot.Hash` matches the expected visualsign-parser binary.

#### Step 4: Validate PCRs

Verify PCR values from the manifest.

### Reproducing the SHA256

To independently verify the visualsign-parser binary hash:

```bash
# Clone and build visualsign-parser
git clone https://github.com/anchorageoss/visualsign-parser
cd visualsign-parser
make build

# Verify SHA256 matches Pivot.Hash in manifest
sha256sum build/visualsign-parser
```

## Reference Implementation

The complete verification implementation is available in the [`verify/service.go`](https://github.com/anchorageoss/visualsign-turnkeyclient/blob/24886a1a9e5cb4f39b8f88cd9c0ef31603074683/verify/service.go) file. Key verification steps:

- [Boot attestation validation](https://github.com/anchorageoss/visualsign-turnkeyclient/blob/24886a1a9e5cb4f39b8f88cd9c0ef31603074683/verify/service.go#L95-L109) (Level 2)
- [Manifest processing and hash verification](https://github.com/anchorageoss/visualsign-turnkeyclient/blob/24886a1a9e5cb4f39b8f88cd9c0ef31603074683/verify/service.go#L251-L343) (Level 3)
- [ECDSA signature verification](https://github.com/anchorageoss/visualsign-turnkeyclient/blob/24886a1a9e5cb4f39b8f88cd9c0ef31603074683/verify/service.go#L150-L160) (All levels)
- [Turnkey Boot Proofs](https://docs.rs/turnkey_proofs/latest/turnkey_proofs/#boot-proofs) for detailed attestation structure.

### Understanding PCR Measurements

PCR (Platform Configuration Register) values are SHA-384 hashes identifying the enclave configuration:

| PCR | Measures | Security Property |
|-----|----------|-------------------|
| **PCR0** | Hash over kernel, command line, and all ramdisk sections | Verifies complete enclave image |
| **PCR1** | Hash over kernel, command line, and first ramdisk | Validates boot environment |
| **PCR2** | Hash over subsequent ramdisk sections | Confirms additional components |
| **PCR3** | IAM role + Instance ID | Ties to AWS identity (dynamic) |

#### Important PCR Limitations

As documented in the [Trail of Bits analysis](https://blog.trailofbits.com/2024/02/16/a-few-notes-on-aws-nitro-enclaves-images-and-attestation/), PCR measurements have limitations:

- **Section Concatenation**: PCRs concatenate section data without domain separation, meaning "bytes can be moved between adjacent sections without changing PCRs"
- **Metadata Exclusion**: The metadata section of EIF files is not attested
- **Parser Discrepancies**: The public `nitro-cli describe-eif` parser may differ from the hypervisor parser

**Security Recommendations**:
1. Verify PCR0, PCR1, and PCR2 together (not in isolation)
2. For strongest guarantees, use Level 3 with manifest verification (Pivot.Hash)
3. Skip PCR3 validation as it changes per instance
4. Do not rely solely on PCRs for binary identification - use manifest Pivot.Hash

---

#### Public Key Verification Order

**CRITICAL**: Always verify attestation before trusting the public key

```
// Extract attestations from API response
	appAttestation, bootAttestationDoc, err := s.extractAttestations(response)
	if err != nil {
		return nil, err
	}

// ❌ Don't do this immediately
pubkey := appAttestation.PublicKey[65:130]
ecdsa.Verify(message)

// ✅ Do this first
// verify boot attestation
_, err := attestationVerifier.Validate(bootAttestationDoc)
if err != nil {
    panic(err)
}
// then you can extract publickey, userdata and continue 
```

The attestation verification proves that the public key was generated inside a legitimate enclave running authorized code.

### Known Limitations

#### 1. Trust in AWS Nitro Hardware

**Assumption**: AWS Nitro hardware is not compromised

**Mitigation**: AWS Nitro has undergone independent audits. See [AWS Nitro Security Design](https://docs.aws.amazon.com/pdfs/whitepapers/latest/security-design-of-aws-nitro-system/security-design-of-aws-nitro-system.pdf). We plan to support other TEE environments in the future.

#### 2. PCR Limitations

**Issue**: PCRs have [structural limitations](https://blog.trailofbits.com/2024/02/16/a-few-notes-on-aws-nitro-enclaves-images-and-attestation/) with section concatenation

**Mitigation**: Use Level 3 manifest verification (Pivot.Hash) for strongest guarantees

#### 3. Monolithic Binary

**Issue**: All chains share a single binary, increasing dependencies and build time with each chain addition.

**Future**: Consider per-chain binaries (`visualsign-parser-solana`, `visualsign-parser-ethereum`, etc.) 

#### 4. Input Signature Verification

**Current State**: Not yet implemented in Level 1

**Roadmap**: Future versions will add input signature verification

### Additional Security Resources

- **AWS Nitro Enclaves**: [Official Documentation (PDF)](https://docs.aws.amazon.com/pdfs/enclaves/latest/user/enclaves-user.pdf)
- **Turnkey Boot Proofs**: [turnkey_proofs Rust crate documentation](https://docs.rs/turnkey_proofs/latest/turnkey_proofs/#boot-proofs)
- **PCR Analysis**: [Trail of Bits: AWS Nitro Enclaves Images and Attestation](https://blog.trailofbits.com/2024/02/16/a-few-notes-on-aws-nitro-enclaves-images-and-attestation/)
- **Reference Implementation**: [visualsign-turnkeyclient on GitHub](https://github.com/anchorageoss/visualsign-turnkeyclient)

---

## Running the Reference Implementation

### Quick Start

```bash
# Clone the repository
git clone https://github.com/anchorageoss/visualsign-turnkeyclient
cd visualsign-turnkeyclient

# Build
make build

# Run verification (all levels)
./bin/visualsign-turnkeyclient verify \
  --host https://api.turnkey.com \
  --organization-id <your-org-id> \
  --key-name <your-key> \
  --unsigned-payload <base64-payload> \
  --qos-manifest-hex <expected-manifest-hash> \
  --pcrs 0:<hex>,1:<hex> \
  --debug

# Decode manifest for inspection
./bin/visualsign-turnkeyclient decode-manifest envelope \
  --file manifest.bin --json
```

### Testing Against QoS Client

You can also run this code against qos_client from Turnkey using `./verify-manifest.sh` (Soon to be migrated to a nightly job)

---

## Additional Resources

- **visualsign-parser**: https://github.com/anchorageoss/visualsign-parser
- **QuorumOS Documentation**: https://github.com/tkhq/qos
- **AWS Nitro Enclaves**: https://aws.amazon.com/ec2/nitro/nitro-enclaves/
- **Turnkey Documentation**: https://docs.turnkey.com/
- **Reference Client**: https://github.com/anchorageoss/visualsign-turnkeyclient

## Support

For questions or issues:
- Open an issue on the reference implementation repository
- Contact Turnkey support for API-related questions
- Review the QuorumOS documentation for manifest details

---

*This guide is maintained by the VisualSign Protocol team and updated regularly as the protocol evolves.*